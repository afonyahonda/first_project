'----------Функция Lambda-----------'

#Данная функция как бы упрощает написание кода, в отличии от написания через команду def
# ПРИМЕР 1 с def
# def rectangle_area(a,b):
#     return a*b
# print(rectangle_area(5,9))

#ПРИМЕР 1 c lambda
# print ((lambda a,b: a*b)(5,9))

# ПРИМЕР 2 с def
# def max(a,b):
#     if a >b:
#         return(a)
#     else:
#         return(b)
# print(max(22,20))

#ПРИМЕР 2 c lambda
# print((lambda a, b: a if a > b else b)(22, 20))

#ПРИМЕР 3 c lambda
# print ((lambda a,b: a*b*a)(5,6))

# ПРИМЕР 4 с def
# def square(a):
#     return a*a #мы написали return чтобы получить результат
# print(square(5))

# ПРИМЕР 4 с lambda
# print = square = ((lambda a,b: a*a)(5,6))

# ПРИМЕР 5 с def
# def triple(a):
#     return a*3
# print(triple(10))

# ПРИМЕР 5 с lambda
# triple = lambda a: a*3
# print(triple(10))

"-----КОГДА ИСПОЬЗОВАТЬ LAMBDA ФУНКЦИИ------"
"КОГДА НАМ НУЖНО ВЫЧИСЛИТЬ РЕЗУЛЬТАТ С ПОМОЩЬЮ КАКОГО-ЛИБО ВЫРАЖЕНИЯ"
"КОГДА НАМ НЕ НУЖНО СОВЕРШАТЬ НЕНУЖНЫЕ ВЫЗОВЫ ФУНКЦИЙ"
"С ФУНКЦИЯМИ ВЫСШЕГО ПОРЯДКА (map, filter)"

'----------------MAP-------------'
"""
"MAP - ВСТРОЕННАЯ ФУНКЦИЯ ПРИНИМАЮЩЕГО В КАЧЕСТВЕ АРГУМЕНТА ФУНКЦИЮ И ПОСЛЕДОВАТЕЛЬНОСТЬ (list, tuple, set)
 MAP - ВЫПОЛНЯЕТ ПЕРЕДАННУЮ ФУНКЦИЮ ДЛЯ КАЖДОГО ЭЛЕМЕНТА ПОСЛЕДОВАТЕЛЬНОСТИ"
"""

#ПРИМЕР 1 c def
# def double(a):
#     return a * 2
# my_list = [1, 10, 30, 50, 100]
# double_list = list(map(double, my_list))
# print(double_list)

#ПРИМЕР 1 c lambda
# my_list = [1, 10, 30, 50, 100]
# double_list = list(map(lambda a: a*2, my_list))
# print(double_list)

#ПРИМЕР 2
# lst = [4, 6, 8, 12, 5, 2, 3]
# mapped_lst = list(map(lambda item: item + 100, lst))
# print(mapped_lst)
# Вызываем функцию map() и передаем ей 2 параметра
# Первый параметр: лямбда функция с одним параметром, к которому она прибавляет 100
# Второй параметр: сам список, каждый элемент которого надо изменить в соответствии со значением лямбда функции

'-------FILTER-----------'
"""
Метод filter() используется для фильтрации итерируемых объектов (list, set, dict и проч.) 
с помощью другого метода, переданного в качестве аргумента, который определит правила 
фильтрации. Синтаксис выглядит следующим образом: filter(метод, итерируемый_объект)
"""
# lst = [1, 22, 45, 67, 88, 33, 7, 5]
# filtered_lst = list(filter(lambda item: (item % 2 == 0), lst))
# print(filtered_lst)
# Передаем функции filter() 2 параметра
# Первый параметр: лямбда функция, которая возвращает True, если элемент списка четный
# Второй параметр: сам список, который необходимо профильтровать

'------------РЕКУРСИЯ---------'
""""
РЕКУРСИЯ - ЭТО ВОЗМОЖНОСТЬ ФУНКЦИИ ВЫПОЛНЯТЬ САМУ СЕБЯ.
Т.Е ВЫЗЫВАТЬ ФУНКЦИЮ В НЕЙ ЖЕ САМОЙ
"""
#ПРИМЕР 1 Вывести числа в указанном диапазоне (start, end)
# def increase(start, end):
#     print(start)
#     if start == end:
#         return start
#     else:
#         increase(start+1, end)
# increase(1,15)

#ПРИМЕР 2 Нахождение факториала
# def calculate_factorial(n):
#     if n ==1:
#         return n
#     else:
#         return n*calculate_factorial(n-1)
# result = calculate_factorial(6)
# print(result)

"""
Написать lambda функцию, которая принимает 3 параметра и умножает все параметры между собой.
Функция должна вернуть строку: "Объём коробки" и значение которое получилось.
"""
# triple = lambda a,b,c: a*b*c/1000000
# a = int(input('Введите длину коробки(см): '))
# b = int(input('Введите ширину коробки(см): '))
# c = int(input('Введите высоту коробки(см): '))
# print('Объем коробки:', triple(a,b,c), 'кубов')

"""
Написать lambda функцию, которая принимает 1 параметр количество лет.
Посчитайте количество дней в n лет. 1 год = 365.
"""
# triple = lambda a: a*365
# a = int(input('Введите ваш возраст: '))
# print('Вы прожили', triple(a), 'дней')

"""
Напишите программу которая выводит только нечётные числа с помощью рекурсии.
"""
# def print_odd_numbers(n): #принимает параметр n
#     if n <=0: #используем условие if для проверки является ли текущее число n нечетным
#         return
#     if n % 2 !=0:
#         print(n) #если число нечетное выводим на экран
#     print_odd_numbers(n-1) #затем вызываем функцию odd_numbers рекурсивно уменьшая значение на 1
# #рекурсия продолжается до тех пор, пока значение n не достигнет 0
# n=int(input('Введите число N:')) 
# print('Нечетные числа:')
# print_odd_numbers(n)
    
"""
Написать lambda которая получает сколько дней ПРОШЛО с нового года как параметр
и говорит пользователю сколько дней ОСТАЛОСЬ до нового года.
"""
get_days_left = lambda days_passed: 365 - days_passed
days_passed = int(input('Введите сколько дней прошло с нового года: '))
days_left = get_days_left(days_passed)
print('До нового года осталось:', days_left, 'дней')
"""
В этом примере мы создаем лямбда-функцию #get_days_left, которая принимает параметр #days_passed (кол-во дней, прошедших с НГ).
Внутри лямбда-функции мы используем выражение #365 - days_passed, чтобы вычислить кол-во оставшихся дней до НГ.
Затем мы запрашиваем кол-во дней, прошедших с НГ, с помощью функции #input(), преобразуем его в целое число с помощью #int() 
и сохраняем в переменную #days_passed. Далее мы вызываем лямбда-функцию #get_days_left, передавая ей #days_passed в качестве аргумента,
и сохраняем результат в переменную #days_left. Выводим сообщение сколько дней осталось до НГ,с помощью функции #print().
"""